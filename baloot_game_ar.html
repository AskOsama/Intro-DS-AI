<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>لعبة البلوت - ساحة الذكاء الاصطناعي | DS-AI Course</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        /* ============================================================
         * SECTION 1: CSS VARIABLES & ROOT STYLES
         * ============================================================ */
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-card: #21262d;
            --bg-hover: #30363d;
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --border-color: #30363d;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
            --accent-gold: #ffd700;
            --card-red: #e74c3c;
            --card-black: #2c3e50;
            --team1-color: #3498db;
            --team2-color: #e67e22;
            --trump-glow: rgba(241, 196, 15, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.6;
            direction: rtl;
            text-align: right;
        }

        /* ============================================================
         * SECTION 2: LAYOUT COMPONENTS
         * ============================================================ */
        .demo-header {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            padding: 1.5rem 2rem;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }

        .demo-header h1 {
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }

        .demo-header p {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .main-container {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            gap: 1rem;
            padding: 1rem;
            max-width: 1600px;
            margin: 0 auto;
            min-height: calc(100vh - 120px);
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 1rem;
        }

        .panel-header {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* ============================================================
         * SECTION 3: GAME TABLE LAYOUT
         * ============================================================ */
        .game-table {
            display: grid;
            grid-template-areas:
                ".     north  ."
                "west  center east"
                ".     south  .";
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto 1fr auto;
            gap: 0.5rem;
            height: 100%;
            min-height: 500px;
        }

        .player-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
        }

        .player-area[data-position="north"] { grid-area: north; }
        .player-area[data-position="south"] { grid-area: south; }
        .player-area[data-position="east"] {
            grid-area: east;
            flex-direction: row;
        }
        .player-area[data-position="west"] {
            grid-area: west;
            flex-direction: row-reverse;
        }

        .player-info {
            background: var(--bg-card);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            text-align: center;
            min-width: 120px;
            position: relative;
        }

        .player-info.team1 { border-right: 3px solid var(--team1-color); border-left: none; }
        .player-info.team2 { border-right: 3px solid var(--team2-color); border-left: none; }
        .player-info.current-turn {
            box-shadow: 0 0 10px var(--accent-yellow);
            border-color: var(--accent-yellow);
        }

        .player-name {
            font-weight: 600;
            font-size: 0.9rem;
        }

        .player-agent {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .buyer-badge {
            position: absolute;
            top: -8px;
            left: -8px;
            background: var(--accent-gold);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            box-shadow: 0 0 15px var(--accent-gold), 0 2px 8px rgba(0,0,0,0.3);
            border: 3px solid var(--bg-primary);
            z-index: 100;
        }

        .dealer-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            background: var(--accent-blue);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1rem;
            font-weight: bold;
            box-shadow: 0 0 10px var(--accent-blue), 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid var(--bg-primary);
            z-index: 100;
        }

        .buyer-badge.sun-badge {
            animation: rotateSun 3s linear infinite;
        }

        @keyframes rotateSun {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .hand {
            display: flex;
            gap: -30px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 100px;
            direction: ltr;
        }

        .player-area[data-position="east"] .hand,
        .player-area[data-position="west"] .hand {
            flex-direction: column;
            gap: -50px;
        }

        /* ============================================================
         * SECTION 4: CARD STYLES
         * ============================================================ */
        .card {
            width: 70px;
            height: 100px;
            background: linear-gradient(145deg, #ffffff 0%, #f5f5f5 100%);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            user-select: none;
            direction: ltr;
        }

        .card:hover {
            transform: translateY(-8px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.4);
        }

        .card.legal {
            box-shadow: 0 0 12px var(--accent-green);
        }

        .card.selected {
            transform: translateY(-15px);
            box-shadow: 0 0 15px var(--accent-blue);
        }

        .card.trump {
            box-shadow: 0 0 12px var(--trump-glow);
        }

        .card.face-down {
            background: linear-gradient(145deg, #2c3e50 0%, #1a252f 100%);
        }

        .card.face-down::after {
            content: '';
            position: absolute;
            inset: 8px;
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .card-rank {
            font-size: 1.4rem;
            line-height: 1;
        }

        .card-suit {
            font-size: 1.8rem;
            line-height: 1;
        }

        .card[data-suit="hearts"] .card-suit,
        .card[data-suit="diamonds"] .card-suit,
        .card[data-suit="hearts"] .card-rank,
        .card[data-suit="diamonds"] .card-rank {
            color: var(--card-red);
        }

        .card[data-suit="clubs"] .card-suit,
        .card[data-suit="spades"] .card-suit,
        .card[data-suit="clubs"] .card-rank,
        .card[data-suit="spades"] .card-rank {
            color: var(--card-black);
        }

        .card.playing {
            animation: playCard 0.3s ease-out forwards;
        }

        @keyframes playCard {
            to {
                transform: scale(0.8);
                opacity: 0.5;
            }
        }

        /* ============================================================
         * SECTION 5: CENTER/TRICK AREA
         * ============================================================ */
        .center-area {
            grid-area: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 1rem;
        }

        .trick-area {
            background: radial-gradient(ellipse at center, #1a4d1a 0%, #0d260d 100%);
            border-radius: 50%;
            width: 300px;
            height: 300px;
            display: grid;
            grid-template-areas:
                ".     north  ."
                "west  center east"
                ".     south  .";
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            padding: 1rem;
            position: relative;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.5), 0 4px 20px rgba(0,0,0,0.3);
            border: 4px solid #2d5a2d;
        }

        .trick-card {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .trick-card[data-position="north"] { grid-area: north; }
        .trick-card[data-position="south"] { grid-area: south; }
        .trick-card[data-position="east"] { grid-area: east; }
        .trick-card[data-position="west"] { grid-area: west; }

        .trick-card .card {
            transform: scale(0.9);
        }

        .card.ikah {
            animation: ikahPulse 0.6s ease-in-out;
            box-shadow: 0 0 20px var(--accent-gold), 0 0 30px var(--accent-gold);
        }

        @keyframes ikahPulse {
            0%, 100% { transform: scale(0.9); }
            50% { transform: scale(1.05); }
        }

        .trick-info {
            position: absolute;
            bottom: -30px;
            background: var(--bg-card);
            padding: 0.25rem 0.75rem;
            border-radius: 4px;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .game-info {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .trump-indicator {
            background: var(--bg-card);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
        }

        .trump-indicator.sun {
            border: 2px solid var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .trump-indicator.hokum {
            border: 2px solid var(--accent-purple);
        }

        .trump-suit {
            font-size: 1.5rem;
        }

        /* ============================================================
         * SECTION 6: SCOREBOARD
         * ============================================================ */
        .scoreboard {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .team-score {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 8px;
            text-align: center;
        }

        .team-score.team1 {
            border-top: 3px solid var(--team1-color);
        }

        .team-score.team2 {
            border-top: 3px solid var(--team2-color);
        }

        .team-label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }

        .score-value {
            font-size: 2.5rem;
            font-weight: 700;
        }

        .score-target {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .round-info {
            text-align: center;
            padding: 0.5rem;
            background: var(--bg-card);
            border-radius: 6px;
        }

        /* ============================================================
         * SECTION 7: BIDDING OVERLAY
         * ============================================================ */
        .bidding-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .bidding-overlay.active {
            display: flex;
        }

        .bidding-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border-color);
        }

        .bidding-header {
            text-align: center;
            margin-bottom: 1.5rem;
        }

        .bidding-header h2 {
            margin-bottom: 0.5rem;
        }

        .bidding-card-display {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
        }

        .bidding-card-display .card {
            transform: scale(1.3);
        }

        .bid-options {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-bottom: 1.5rem;
        }

        .bid-btn {
            padding: 1rem;
            border: 2px solid var(--border-color);
            background: var(--bg-card);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.2s;
        }

        .bid-btn:hover:not(:disabled) {
            background: var(--bg-hover);
            border-color: var(--accent-blue);
        }

        .bid-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .bid-btn.hokum { border-color: var(--accent-purple); }
        .bid-btn.sun { border-color: var(--accent-yellow); }
        .bid-btn.pass { border-color: var(--text-muted); }

        .bid-history {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 1rem;
            max-height: 150px;
            overflow-y: auto;
        }

        .bid-entry {
            padding: 0.25rem 0;
            font-size: 0.9rem;
            border-bottom: 1px solid var(--border-color);
        }

        .bid-entry:last-child {
            border-bottom: none;
        }

        /* ============================================================
         * SECTION 8: SUIT SELECTION MODAL
         * ============================================================ */
        .suit-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 110;
            align-items: center;
            justify-content: center;
        }

        .suit-modal.active {
            display: flex;
        }

        .suit-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            text-align: center;
        }

        .suit-options {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
            direction: ltr;
        }

        .suit-btn {
            width: 80px;
            height: 80px;
            border: 2px solid var(--border-color);
            background: var(--bg-card);
            border-radius: 8px;
            cursor: pointer;
            font-size: 3rem;
            transition: all 0.2s;
        }

        .suit-btn:hover {
            transform: scale(1.1);
            border-color: var(--accent-blue);
        }

        .suit-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* ============================================================
         * SECTION 9: PROJECTS MODAL
         * ============================================================ */
        .projects-modal {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }

        .projects-modal.active {
            display: flex;
        }

        .projects-panel {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 2rem;
            max-width: 600px;
            width: 90%;
        }

        .project-item {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .project-cards {
            display: flex;
            gap: 0.25rem;
            direction: ltr;
        }

        .project-cards .card {
            transform: scale(0.6);
        }

        .project-points {
            font-weight: 700;
            color: var(--accent-green);
        }

        /* ============================================================
         * SECTION 10: DOUBLING PANEL
         * ============================================================ */
        .double-panel {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .double-btns {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .double-btn {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .double-btn:hover:not(:disabled) {
            border-color: var(--accent-red);
        }

        .double-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .double-level {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            color: var(--accent-yellow);
        }

        /* ============================================================
         * SECTION 11: GAME CONTROLS
         * ============================================================ */
        .controls-section {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .control-group {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 6px;
        }

        .control-group label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .control-group select,
        .control-group input[type="range"] {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.95rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--accent-blue);
            color: white;
        }

        .btn-primary:hover {
            background: #4393e6;
        }

        .btn-secondary {
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-hover);
        }

        .btn-danger {
            background: var(--accent-red);
            color: white;
        }

        /* ============================================================
         * SECTION 12: AI UPLOAD
         * ============================================================ */
        .ai-upload-section {
            margin-top: 1rem;
        }

        .ai-upload-group {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 6px;
            margin-bottom: 0.75rem;
        }

        .ai-upload-group.team1 {
            border-right: 3px solid var(--team1-color);
            border-left: none;
        }

        .ai-upload-group.team2 {
            border-right: 3px solid var(--team2-color);
            border-left: none;
        }

        .ai-name {
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .file-input-wrapper {
            position: relative;
        }

        .file-input-wrapper input[type="file"] {
            width: 100%;
            padding: 0.5rem;
            background: var(--bg-secondary);
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
        }

        /* ============================================================
         * SECTION 13: REPLAY CONTROLS
         * ============================================================ */
        .replay-section {
            background: var(--bg-card);
            padding: 1rem;
            border-radius: 8px;
        }

        .replay-slider {
            width: 100%;
            margin: 1rem 0;
        }

        .replay-buttons {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            direction: ltr;
        }

        .replay-btn {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .replay-btn:hover {
            background: var(--bg-hover);
        }

        .replay-info {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--text-secondary);
            max-height: 100px;
            overflow-y: auto;
            background: var(--bg-secondary);
            padding: 0.5rem;
            border-radius: 4px;
        }

        /* ============================================================
         * SECTION 14: TIMER
         * ============================================================ */
        .timer-display {
            text-align: center;
            margin-bottom: 1rem;
        }

        .timer-bar {
            height: 6px;
            background: var(--bg-card);
            border-radius: 3px;
            overflow: hidden;
        }

        .timer-fill {
            height: 100%;
            background: var(--accent-green);
            transition: width 0.1s linear;
        }

        .timer-fill.warning {
            background: var(--accent-red);
        }

        .timer-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 0.25rem;
        }

        /* ============================================================
         * SECTION 15: GAME LOG
         * ============================================================ */
        .game-log {
            background: var(--bg-card);
            border-radius: 6px;
            padding: 0.75rem;
            height: 200px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 0.8rem;
            direction: ltr;
            text-align: left;
        }

        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border-color);
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-entry.info { color: var(--text-secondary); }
        .log-entry.success { color: var(--accent-green); }
        .log-entry.warning { color: var(--accent-yellow); }
        .log-entry.error { color: var(--accent-red); }
        .log-entry.bid { color: var(--accent-purple); }
        .log-entry.play { color: var(--accent-blue); }
        .log-entry.ikah {
            color: var(--accent-gold);
            font-weight: bold;
        }

        .log-time {
            color: var(--text-muted);
            margin-right: 0.5rem;
        }

        /* ============================================================
         * SECTION 16: GAME END OVERLAY
         * ============================================================ */
        .game-end-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            align-items: center;
            justify-content: center;
        }

        .game-end-overlay.active {
            display: flex;
        }

        .game-end-panel {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 3rem;
            text-align: center;
            border: 2px solid var(--accent-yellow);
        }

        .game-end-panel h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }

        .final-scores {
            display: flex;
            gap: 2rem;
            justify-content: center;
            margin: 1.5rem 0;
        }

        .final-score {
            padding: 1rem 2rem;
            border-radius: 8px;
        }

        .final-score.winner {
            background: rgba(59, 185, 80, 0.2);
            border: 2px solid var(--accent-green);
        }

        .final-score .score {
            font-size: 3rem;
            font-weight: 700;
        }

        /* ============================================================
         * SECTION 17: RESPONSIVE
         * ============================================================ */
        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }

            .game-table {
                min-height: 400px;
            }

            .trick-area {
                width: 250px;
                height: 250px;
            }
        }

        @media (max-width: 768px) {
            .card {
                width: 50px;
                height: 72px;
            }

            .card-rank { font-size: 1rem; }
            .card-suit { font-size: 1.2rem; }

            .trick-area {
                width: 200px;
                height: 200px;
            }
        }
    </style>
</head>
<body>
    <!-- ============================================================
         HEADER
         ============================================================ -->
    <header class="demo-header">
        <h1>لعبة البلوت - ساحة الذكاء الاصطناعي</h1>
        <p>شاهد وكلاء الذكاء الاصطناعي يتنافسون في لعبة الورق السعودية الكلاسيكية</p>
    </header>

    <!-- ============================================================
         MAIN CONTAINER
         ============================================================ -->
    <div class="main-container">
        <!-- RIGHT PANEL (appears first in RTL): Controls & AI Upload -->
        <aside class="panel">
            <div class="panel-header">التحكم باللعبة</div>

            <div class="controls-section">
                <!-- Game Actions -->
                <div class="control-group">
                    <button class="btn btn-primary" id="startGameBtn" onclick="GameController.startNewGame()">
                        بدء لعبة جديدة
                    </button>
                </div>

                <!-- Speed Control -->
                <div class="control-group">
                    <label>سرعة الحركة</label>
                    <select id="speedSelect" onchange="GameController.setSpeed(this.value)">
                        <option value="slow">بطيء</option>
                        <option value="normal" selected>عادي</option>
                        <option value="fast">سريع</option>
                        <option value="instant">فوري</option>
                    </select>
                </div>

                <!-- Timer Control -->
                <div class="control-group">
                    <label>مهلة قرار الذكاء الاصطناعي: <span id="timeoutValue">5</span> ثانية</label>
                    <input type="range" id="timeoutSlider" min="1" max="30" value="5"
                           oninput="document.getElementById('timeoutValue').textContent = this.value; gameState.config.aiDecisionTimeout = this.value * 1000;">
                </div>
            </div>

            <!-- AI Upload Section -->
            <div class="ai-upload-section">
                <div class="panel-header">وكلاء الذكاء الاصطناعي</div>

                <div class="ai-upload-group team1">
                    <div class="ai-name">الفريق 1 (شمال-جنوب)</div>
                    <div id="team1AgentName">GreedyAI</div>
                    <div class="file-input-wrapper">
                        <input type="file" id="team1AIUpload" accept=".js" onchange="AIUploadSystem.handleUpload(event, 0)">
                    </div>
                </div>

                <div class="ai-upload-group team2">
                    <div class="ai-name">الفريق 2 (شرق-غرب)</div>
                    <div id="team2AgentName">StrategicAI</div>
                    <div class="file-input-wrapper">
                        <input type="file" id="team2AIUpload" accept=".js" onchange="AIUploadSystem.handleUpload(event, 1)">
                    </div>
                </div>

                <button class="btn btn-secondary" style="width: 100%; margin-top: 0.5rem;" onclick="AIUploadSystem.downloadTemplate()">
                    تحميل قالب الذكاء الاصطناعي
                </button>
                <button class="btn btn-secondary" style="width: 100%; margin-top: 0.5rem; background: var(--accent-purple); border-color: var(--accent-purple);" onclick="AIUploadSystem.downloadDeveloperGuide()">
                    تحميل دليل المطور
                </button>
            </div>

            <!-- Timer Display -->
            <div id="timerDisplay" class="timer-display"></div>
        </aside>

        <!-- CENTER: Game Table -->
        <main class="panel">
            <div class="game-table">
                <!-- North Player (Team 1) -->
                <div class="player-area" data-position="north">
                    <div class="player-info team1" id="playerInfo0">
                        <div class="player-name">الشمال</div>
                        <div class="player-agent">GreedyAI</div>
                    </div>
                    <div class="hand" id="hand0"></div>
                </div>

                <!-- West Player (Team 2) -->
                <div class="player-area" data-position="west">
                    <div class="player-info team2" id="playerInfo3">
                        <div class="player-name">الغرب</div>
                        <div class="player-agent">StrategicAI</div>
                    </div>
                    <div class="hand" id="hand3"></div>
                </div>

                <!-- Center: Trick Area -->
                <div class="center-area">
                    <div class="game-info">
                        <div class="trump-indicator" id="trumpIndicator">
                            <span>في الانتظار...</span>
                        </div>
                    </div>

                    <div class="trick-area" id="trickArea">
                        <div class="trick-card" data-position="north"></div>
                        <div class="trick-card" data-position="west"></div>
                        <div class="trick-card" data-position="east"></div>
                        <div class="trick-card" data-position="south"></div>
                        <div class="trick-info" id="trickInfo">الأكلة 0/8</div>
                    </div>
                </div>

                <!-- East Player (Team 2) -->
                <div class="player-area" data-position="east">
                    <div class="player-info team2" id="playerInfo1">
                        <div class="player-name">الشرق</div>
                        <div class="player-agent">StrategicAI</div>
                    </div>
                    <div class="hand" id="hand1"></div>
                </div>

                <!-- South Player (Team 1) -->
                <div class="player-area" data-position="south">
                    <div class="player-info team1" id="playerInfo2">
                        <div class="player-name">الجنوب</div>
                        <div class="player-agent">GreedyAI</div>
                    </div>
                    <div class="hand" id="hand2"></div>
                </div>
            </div>
        </main>

        <!-- LEFT PANEL (appears last in RTL): Scoreboard & Log -->
        <aside class="panel">
            <div class="panel-header">لوحة النتائج</div>

            <div class="scoreboard">
                <div class="team-score team1">
                    <div class="team-label">الفريق 1 (شمال-جنوب)</div>
                    <div class="score-value" id="team1Score">0</div>
                    <div class="score-target">/ 152</div>
                </div>

                <div class="round-info">
                    <span>الجولة: <strong id="roundNumber">1</strong></span>
                    <span id="buyerInfo"></span>
                </div>

                <div class="team-score team2">
                    <div class="team-label">الفريق 2 (شرق-غرب)</div>
                    <div class="score-value" id="team2Score">0</div>
                    <div class="score-target">/ 152</div>
                </div>
            </div>

            <!-- Replay Section -->
            <div class="replay-section" style="margin-top: 1rem;">
                <div class="panel-header">الإعادة</div>
                <input type="range" class="replay-slider" id="replaySlider" min="0" max="0" value="0"
                       oninput="ReplaySystem.goToAction(parseInt(this.value))">
                <div class="replay-buttons">
                    <button class="replay-btn" onclick="ReplaySystem.goToStart()" title="البداية">|&lt;</button>
                    <button class="replay-btn" onclick="ReplaySystem.stepBack()" title="السابق">&lt;</button>
                    <button class="replay-btn" id="replayPlayBtn" onclick="ReplaySystem.toggleAutoPlay()" title="تشغيل/إيقاف">&#9654;</button>
                    <button class="replay-btn" onclick="ReplaySystem.stepForward()" title="التالي">&gt;</button>
                    <button class="replay-btn" onclick="ReplaySystem.goToEnd()" title="النهاية">&gt;|</button>
                </div>
                <div class="replay-info" id="replayInfo"></div>
            </div>

            <!-- Game Log -->
            <div style="margin-top: 1rem;">
                <div class="panel-header">سجل اللعبة</div>
                <div class="game-log" id="gameLog"></div>
            </div>
        </aside>
    </div>

    <!-- ============================================================
         BIDDING OVERLAY
         ============================================================ -->
    <div class="bidding-overlay" id="biddingOverlay">
        <div class="bidding-panel">
            <div class="bidding-header">
                <h2>مرحلة المزايدة</h2>
                <p id="biddingStatus">في انتظار المزايدات...</p>
            </div>

            <div class="bidding-card-display" id="biddingCardDisplay"></div>

            <div class="bid-options" id="bidOptions"></div>

            <div class="bid-history" id="bidHistory">
                <div style="color: var(--text-muted); text-align: center;">ستظهر المزايدات هنا...</div>
            </div>
        </div>
    </div>

    <!-- ============================================================
         SUIT SELECTION MODAL
         ============================================================ -->
    <div class="suit-modal" id="suitModal">
        <div class="suit-panel">
            <h3>اختر نوع الحكم</h3>
            <p>اختر نوعًا مختلفًا عن ورقة المزايدة</p>
            <div class="suit-options" id="suitOptions"></div>
        </div>
    </div>

    <!-- ============================================================
         PROJECTS MODAL
         ============================================================ -->
    <div class="projects-modal" id="projectsModal">
        <div class="projects-panel">
            <h3>المشاريع المعلنة</h3>
            <div id="projectsList"></div>
            <button class="btn btn-primary" style="margin-top: 1rem;" onclick="UIRenderer.closeProjectsModal()">متابعة</button>
        </div>
    </div>

    <!-- ============================================================
         GAME END OVERLAY
         ============================================================ -->
    <div class="game-end-overlay" id="gameEndOverlay">
        <div class="game-end-panel">
            <h2 id="winnerText">انتهت اللعبة!</h2>
            <div class="final-scores">
                <div class="final-score" id="finalScore1">
                    <div class="team-label">الفريق 1</div>
                    <div class="score">0</div>
                </div>
                <div class="final-score" id="finalScore2">
                    <div class="team-label">الفريق 2</div>
                    <div class="score">0</div>
                </div>
            </div>
            <button class="btn btn-primary" onclick="GameController.startNewGame()">العب مرة أخرى</button>
        </div>
    </div>

    <!-- ============================================================
         JAVASCRIPT
         ============================================================ -->
    <script>
        // ============================================================
        // SECTION 1: CONSTANTS & ENUMS
        // ============================================================

        const SUITS = Object.freeze({
            CLUBS: 'clubs',
            DIAMONDS: 'diamonds',
            HEARTS: 'hearts',
            SPADES: 'spades'
        });

        const RANKS = Object.freeze({
            SEVEN: '7',
            EIGHT: '8',
            NINE: '9',
            TEN: '10',
            JACK: 'J',
            QUEEN: 'Q',
            KING: 'K',
            ACE: 'A'
        });

        const SUIT_SYMBOLS = {
            clubs: '\u2663',
            diamonds: '\u2666',
            hearts: '\u2665',
            spades: '\u2660'
        };

        const SUIT_NAMES = {
            clubs: 'سباتي',
            diamonds: 'ديناري',
            hearts: 'كبة',
            spades: 'بستوني'
        };

        const SUIT_NAMES_EN = {
            clubs: 'Clubs',
            diamonds: 'Diamonds',
            hearts: 'Hearts',
            spades: 'Spades'
        };

        const BID_TYPES = Object.freeze({
            PASS: 'pass',
            HOKUM: 'hokum',
            SUN: 'sun',
            HOKUM_SECOND: 'hokum2',
            ASHKAL: 'ashkal'
        });

        const BID_NAMES_AR = {
            pass: 'بس',
            hokum: 'حكم',
            sun: 'صن',
            hokum2: 'حكم ثاني',
            ashkal: 'أشكل'
        };

        const POSITIONS = ['north', 'east', 'south', 'west'];
        const POSITION_TO_INDEX = { north: 0, east: 1, south: 2, west: 3 };
        const POSITION_NAMES_AR = { north: 'الشمال', east: 'الشرق', south: 'الجنوب', west: 'الغرب' };

        // ============================================================
        // SECTION 2: CARD SYSTEM
        // ============================================================

        class Card {
            constructor(suit, rank) {
                this.suit = suit;
                this.rank = rank;
                this.id = `${rank}-${suit}`;
            }

            getPointValue(gameType, isTrump) {
                if (gameType === 'hokum' && isTrump) {
                    const trumpValues = { 'J': 20, '9': 14, 'A': 11, '10': 10, 'K': 4, 'Q': 3, '8': 0, '7': 0 };
                    return trumpValues[this.rank];
                }
                const normalValues = { 'A': 11, '10': 10, 'K': 4, 'Q': 3, 'J': 2, '9': 0, '8': 0, '7': 0 };
                return normalValues[this.rank];
            }

            getRankingPower(gameType, isTrump) {
                if (gameType === 'hokum' && isTrump) {
                    const trumpRanking = { 'J': 7, '9': 6, 'A': 5, '10': 4, 'K': 3, 'Q': 2, '8': 1, '7': 0 };
                    return trumpRanking[this.rank];
                }
                const normalRanking = { 'A': 7, '10': 6, 'K': 5, 'Q': 4, 'J': 3, '9': 2, '8': 1, '7': 0 };
                return normalRanking[this.rank];
            }

            getSequenceValue() {
                const seqValues = { '7': 0, '8': 1, '9': 2, '10': 3, 'J': 4, 'Q': 5, 'K': 6, 'A': 7 };
                return seqValues[this.rank];
            }

            toString() {
                return `${this.rank}${SUIT_SYMBOLS[this.suit]}`;
            }

            toElement(faceDown = false) {
                const el = document.createElement('div');
                el.className = `card${faceDown ? ' face-down' : ''}`;
                el.dataset.id = this.id;
                el.dataset.suit = this.suit;
                el.dataset.rank = this.rank;

                if (!faceDown) {
                    el.innerHTML = `
                        <span class="card-rank">${this.rank}</span>
                        <span class="card-suit">${SUIT_SYMBOLS[this.suit]}</span>
                    `;
                }
                return el;
            }
        }

        // ============================================================
        // SECTION 3: GAME STATE
        // ============================================================

        const initialRoundState = {
            phase: 'waiting',
            gameType: null,
            trumpSuit: null,
            buyer: null,
            buyingTeam: null,
            biddingCard: null,
            biddingRound: 1,
            bids: [],
            currentBidder: null,
            hokumDeclared: false,
            currentTrick: [],
            playedCards: [],
            trickNumber: 0,
            trickLeader: null,
            currentPlayer: null,
            team1Tricks: [],
            team2Tricks: [],
            declaredProjects: { team1: [], team2: [] },
            doubleLevel: 1,
            lastDoubler: null,
            isLocked: false
        };

        const gameState = {
            config: {
                winningScore: 152,
                aiDecisionTimeout: 5000,
                animationSpeed: 'normal'
            },
            match: {
                team1Score: 0,
                team2Score: 0,
                roundNumber: 1,
                dealerIndex: 0,
                winner: null,
                isRunning: false
            },
            round: JSON.parse(JSON.stringify(initialRoundState)),
            players: [
                { index: 0, position: 'north', teamIndex: 0, hand: [], agent: null, name: 'الشمال' },
                { index: 1, position: 'east', teamIndex: 1, hand: [], agent: null, name: 'الشرق' },
                { index: 2, position: 'south', teamIndex: 0, hand: [], agent: null, name: 'الجنوب' },
                { index: 3, position: 'west', teamIndex: 1, hand: [], agent: null, name: 'الغرب' }
            ],
            deck: {
                cards: [],
                dealt: false
            },
            history: {
                actions: [],
                currentIndex: -1,
                isReplaying: false
            },
            timer: {
                startTime: null,
                remaining: null
            }
        };

        // ============================================================
        // SECTION 4: DECK MANAGEMENT
        // ============================================================

        const DeckManager = {
            createDeck() {
                const deck = [];
                for (const suit of Object.values(SUITS)) {
                    for (const rank of Object.values(RANKS)) {
                        deck.push(new Card(suit, rank));
                    }
                }
                return deck;
            },

            shuffle(deck) {
                const shuffled = [...deck];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            },

            deal(phase) {
                const deck = gameState.deck.cards;
                const dealerIndex = gameState.match.dealerIndex;
                const dealOrder = [(dealerIndex + 1) % 4, (dealerIndex + 2) % 4, (dealerIndex + 3) % 4, dealerIndex];

                if (phase === 1) {
                    for (let round = 0; round < 3; round++) {
                        for (const idx of dealOrder) {
                            gameState.players[idx].hand.push(deck.pop());
                        }
                    }
                    gameState.round.biddingCard = deck.pop();

                } else if (phase === 2) {
                    for (let round = 0; round < 2; round++) {
                        for (const idx of dealOrder) {
                            gameState.players[idx].hand.push(deck.pop());
                        }
                    }

                    if (gameState.round.gameType === 'hokum' && gameState.round.buyer !== null) {
                        gameState.players[gameState.round.buyer].hand.push(gameState.round.biddingCard);
                    }
                }
            },

            sortHand(hand, trumpSuit) {
                const suitOrder = trumpSuit
                    ? [trumpSuit, ...Object.values(SUITS).filter(s => s !== trumpSuit)]
                    : Object.values(SUITS);

                return hand.sort((a, b) => {
                    const suitDiff = suitOrder.indexOf(a.suit) - suitOrder.indexOf(b.suit);
                    if (suitDiff !== 0) return suitDiff;
                    return b.getSequenceValue() - a.getSequenceValue();
                });
            }
        };

        // ============================================================
        // SECTION 5: BIDDING SYSTEM
        // ============================================================

        const BiddingSystem = {
            getValidBids() {
                const bids = [];
                const round = gameState.round.biddingRound;

                if (round === 1) {
                    bids.push(BID_TYPES.PASS);
                    if (!gameState.round.hokumDeclared) {
                        bids.push(BID_TYPES.HOKUM);
                    }
                    bids.push(BID_TYPES.SUN);
                } else {
                    bids.push(BID_TYPES.PASS);
                    bids.push(BID_TYPES.HOKUM_SECOND);
                    bids.push(BID_TYPES.SUN);
                    bids.push(BID_TYPES.ASHKAL);
                }

                return bids;
            },

            processBid(playerIndex, bidType, suitChoice = null) {
                if (playerIndex !== gameState.round.currentBidder) {
                    return { success: false, message: 'ليس دورك' };
                }

                gameState.round.bids.push({
                    playerIndex,
                    bidType,
                    suitChoice,
                    timestamp: Date.now()
                });

                const biddingCardSuit = gameState.round.biddingCard.suit;

                switch (bidType) {
                    case BID_TYPES.SUN:
                        gameState.round.gameType = 'sun';
                        gameState.round.trumpSuit = null;
                        gameState.round.buyer = playerIndex;
                        gameState.round.buyingTeam = gameState.players[playerIndex].teamIndex;
                        return { success: true, endBidding: true };

                    case BID_TYPES.HOKUM:
                        gameState.round.hokumDeclared = true;
                        gameState.round.gameType = 'hokum';
                        gameState.round.trumpSuit = biddingCardSuit;
                        gameState.round.buyer = playerIndex;
                        gameState.round.buyingTeam = gameState.players[playerIndex].teamIndex;
                        this.advanceToNextBidder();
                        return { success: true, endBidding: false };

                    case BID_TYPES.HOKUM_SECOND:
                        if (!suitChoice || suitChoice === biddingCardSuit) {
                            return { success: false, message: 'يجب اختيار نوع مختلف' };
                        }
                        gameState.round.gameType = 'hokum';
                        gameState.round.trumpSuit = suitChoice;
                        gameState.round.buyer = playerIndex;
                        gameState.round.buyingTeam = gameState.players[playerIndex].teamIndex;
                        return { success: true, endBidding: true };

                    case BID_TYPES.ASHKAL:
                        gameState.round.gameType = 'sun';
                        gameState.round.trumpSuit = null;
                        gameState.round.buyer = playerIndex;
                        gameState.round.buyingTeam = gameState.players[playerIndex].teamIndex;

                        const partnerIndex = (playerIndex + 2) % 4;
                        const biddingCard = gameState.round.biddingCard;

                        const buyerHand = gameState.players[playerIndex].hand;
                        const cardIndex = buyerHand.findIndex(c => c.id === biddingCard.id);
                        if (cardIndex !== -1) {
                            buyerHand.splice(cardIndex, 1);
                        }

                        gameState.players[partnerIndex].hand.push(biddingCard);

                        gameState.players[playerIndex].hand = DeckManager.sortHand(
                            gameState.players[playerIndex].hand, null
                        );
                        gameState.players[partnerIndex].hand = DeckManager.sortHand(
                            gameState.players[partnerIndex].hand, null
                        );

                        return { success: true, endBidding: true, isAshkal: true };

                    case BID_TYPES.PASS:
                        this.advanceToNextBidder();

                        const passCount = gameState.round.bids.filter(b => b.bidType === BID_TYPES.PASS).length;

                        if (gameState.round.biddingRound === 1) {
                            if (passCount === 4 && !gameState.round.hokumDeclared) {
                                gameState.round.biddingRound = 2;
                                gameState.round.bids = [];
                                gameState.round.currentBidder = (gameState.match.dealerIndex + 1) % 4;
                                return { success: true, endBidding: false, newRound: true };
                            } else if (gameState.round.hokumDeclared && this.allOthersPassed()) {
                                return { success: true, endBidding: true };
                            }
                        } else {
                            if (passCount === 4) {
                                return { success: true, endBidding: true, reshuffle: true };
                            }
                        }
                        return { success: true, endBidding: false };
                }
            },

            advanceToNextBidder() {
                gameState.round.currentBidder = (gameState.round.currentBidder + 1) % 4;
            },

            allOthersPassed() {
                const hokumIndex = gameState.round.bids.findIndex(b => b.bidType === BID_TYPES.HOKUM);
                const bidsAfterHokum = gameState.round.bids.slice(hokumIndex + 1);
                return bidsAfterHokum.length === 3 && bidsAfterHokum.every(b => b.bidType === BID_TYPES.PASS);
            },

            startBidding() {
                gameState.round.phase = 'bidding';
                gameState.round.biddingRound = 1;
                gameState.round.currentBidder = (gameState.match.dealerIndex + 1) % 4;
                gameState.round.bids = [];
                gameState.round.hokumDeclared = false;
            }
        };

        // ============================================================
        // SECTION 6: TRICK SYSTEM
        // ============================================================

        const TrickSystem = {
            getLegalCards(playerIndex) {
                const hand = gameState.players[playerIndex].hand;
                const trick = gameState.round.currentTrick;

                if (trick.length === 0) {
                    return this.getLegalLeadCards(playerIndex);
                }

                const ledSuit = trick[0].card.suit;
                const trumpSuit = gameState.round.trumpSuit;
                const gameType = gameState.round.gameType;

                const suitCards = hand.filter(c => c.suit === ledSuit);

                if (suitCards.length > 0) {
                    return suitCards;
                }

                if (gameType === 'sun') {
                    return hand;
                }

                const trumpCards = hand.filter(c => c.suit === trumpSuit);

                if (trumpCards.length === 0) {
                    return hand;
                }

                const partnerIndex = (playerIndex + 2) % 4;
                const winner = this.getCurrentWinner();
                const partnerIsWinning = winner && winner.playerIndex === partnerIndex;

                if (partnerIsWinning) {
                    return hand;
                }

                const highestTrumpInTrick = this.getHighestTrumpInTrick();

                if (highestTrumpInTrick) {
                    const higherTrumps = trumpCards.filter(c =>
                        c.getRankingPower(gameType, true) > highestTrumpInTrick.card.getRankingPower(gameType, true)
                    );
                    if (higherTrumps.length > 0) {
                        return higherTrumps;
                    }
                }

                return trumpCards.length > 0 ? trumpCards : hand;
            },

            getLegalLeadCards(playerIndex) {
                const hand = gameState.players[playerIndex].hand;

                if (gameState.round.isLocked &&
                    playerIndex === gameState.round.buyer &&
                    gameState.round.trumpSuit) {
                    const nonTrump = hand.filter(c => c.suit !== gameState.round.trumpSuit);
                    if (nonTrump.length > 0) return nonTrump;
                }

                return hand;
            },

            getHighestTrumpInTrick() {
                const trumpSuit = gameState.round.trumpSuit;
                if (!trumpSuit) return null;

                const trumpPlays = gameState.round.currentTrick.filter(p => p.card.suit === trumpSuit);
                if (trumpPlays.length === 0) return null;

                return trumpPlays.reduce((highest, play) =>
                    play.card.getRankingPower('hokum', true) > highest.card.getRankingPower('hokum', true)
                        ? play : highest
                );
            },

            getCurrentWinner() {
                const trick = gameState.round.currentTrick;
                if (trick.length === 0) return null;

                const trumpSuit = gameState.round.trumpSuit;
                const gameType = gameState.round.gameType;
                const ledSuit = trick[0].card.suit;

                let winner = trick[0];

                for (let i = 1; i < trick.length; i++) {
                    if (this.cardBeats(trick[i].card, winner.card, ledSuit, trumpSuit, gameType)) {
                        winner = trick[i];
                    }
                }

                return winner;
            },

            cardBeats(cardA, cardB, ledSuit, trumpSuit, gameType) {
                const aIsTrump = trumpSuit && cardA.suit === trumpSuit;
                const bIsTrump = trumpSuit && cardB.suit === trumpSuit;

                if (aIsTrump && !bIsTrump) return true;
                if (!aIsTrump && bIsTrump) return false;

                if (aIsTrump && bIsTrump) {
                    return cardA.getRankingPower(gameType, true) > cardB.getRankingPower(gameType, true);
                }

                const aIsLed = cardA.suit === ledSuit;
                const bIsLed = cardB.suit === ledSuit;

                if (aIsLed && !bIsLed) return true;
                if (!aIsLed && bIsLed) return false;

                if (cardA.suit === cardB.suit) {
                    return cardA.getRankingPower(gameType, false) > cardB.getRankingPower(gameType, false);
                }

                return false;
            },

            isIkah(card, playerIndex) {
                const gameType = gameState.round.gameType;
                const trumpSuit = gameState.round.trumpSuit;

                // Ikah only applies in Hokum mode
                if (gameType !== 'hokum' || !trumpSuit) {
                    return false;
                }

                const playedCards = gameState.round.playedCards || [];
                const playerHand = gameState.players[playerIndex].hand;

                // Get all cards in the same suit that haven't been played yet
                const allRanks = ['7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
                const playedInSuit = playedCards.filter(c => c.suit === card.suit);

                // Check if this card is the highest remaining in the suit
                const cardIsTrump = card.suit === trumpSuit;
                const cardPower = card.getRankingPower(gameType, cardIsTrump);

                for (const rank of allRanks) {
                    const testCard = { suit: card.suit, rank: rank };
                    const testIsTrump = card.suit === trumpSuit;

                    // Skip if this test card has already been played
                    const alreadyPlayed = playedInSuit.some(pc => pc.rank === rank);
                    if (alreadyPlayed) continue;

                    // Check if a higher card exists
                    const testPower = Card.prototype.getRankingPower.call(testCard, gameType, testIsTrump);
                    if (testPower > cardPower) {
                        return false; // Higher card exists that hasn't been played
                    }
                }

                return true; // This is the highest remaining card in the suit
            },

            playCard(playerIndex, card) {
                const hand = gameState.players[playerIndex].hand;
                const cardIndex = hand.findIndex(c => c.id === card.id);

                if (cardIndex === -1) return { success: false };

                hand.splice(cardIndex, 1);

                gameState.round.currentTrick.push({
                    playerIndex,
                    card,
                    timestamp: Date.now()
                });

                gameState.round.currentPlayer = (playerIndex + 1) % 4;

                return { success: true };
            },

            resolveTrick() {
                const winner = this.getCurrentWinner();
                const trickCards = gameState.round.currentTrick.map(p => p.card);

                if (gameState.players[winner.playerIndex].teamIndex === 0) {
                    gameState.round.team1Tricks.push(trickCards);
                } else {
                    gameState.round.team2Tricks.push(trickCards);
                }

                gameState.round.trickNumber++;
                gameState.round.trickLeader = winner.playerIndex;
                gameState.round.currentPlayer = winner.playerIndex;
                gameState.round.currentTrick = [];

                return {
                    winner: winner.playerIndex,
                    cards: trickCards,
                    trickNumber: gameState.round.trickNumber
                };
            }
        };

        // ============================================================
        // SECTION 7: PROJECT SYSTEM
        // ============================================================

        const ProjectSystem = {
            detectProjects(hand, gameType, trumpSuit) {
                const projects = [];

                const sequences = this.findSequences(hand);
                for (const seq of sequences) {
                    if (seq.length >= 3) {
                        let type, points;
                        if (seq.length === 3) {
                            type = 'سرا';
                            points = gameType === 'hokum' ? 2 : 4;
                        } else if (seq.length === 4) {
                            type = 'خمسين';
                            points = gameType === 'hokum' ? 5 : 10;
                        } else {
                            type = 'مية';
                            points = gameType === 'hokum' ? 10 : 20;
                        }
                        projects.push({ type, cards: seq, points });
                    }
                }

                const rankGroups = {};
                for (const card of hand) {
                    if (!rankGroups[card.rank]) rankGroups[card.rank] = [];
                    rankGroups[card.rank].push(card);
                }

                for (const [rank, cards] of Object.entries(rankGroups)) {
                    if (cards.length === 4) {
                        if (rank === 'A' && gameType === 'sun') {
                            projects.push({ type: 'أربعمية', cards, points: 40 });
                        } else {
                            projects.push({ type: 'مية', cards, points: gameType === 'hokum' ? 10 : 20 });
                        }
                    }
                }

                // Detect Baloot (K+Q of trump) - 20 points
                // Per rules line 96-97: K+Q in 5+ card sequence → NO Baloot
                if (trumpSuit && gameType === 'hokum') {
                    const trumpCards = hand.filter(c => c.suit === trumpSuit);
                    const hasKing = trumpCards.some(c => c.rank === 'K');
                    const hasQueen = trumpCards.some(c => c.rank === 'Q');

                    if (hasKing && hasQueen) {
                        // Check if K and Q are part of a mia-sequence (5+ cards)
                        let partOfMiaSequence = false;

                        for (const project of projects) {
                            if (project.type === 'mia' &&
                                project.subtype === 'sequence' &&
                                project.suit === trumpSuit &&
                                project.cards.length >= 5) {

                                const hasKInSeq = project.cards.some(c => c.rank === 'K');
                                const hasQInSeq = project.cards.some(c => c.rank === 'Q');

                                if (hasKInSeq && hasQInSeq) {
                                    partOfMiaSequence = true;
                                    break;
                                }
                            }
                        }

                        // Only add Baloot if NOT part of a 5+ card sequence
                        if (!partOfMiaSequence) {
                            const king = trumpCards.find(c => c.rank === 'K');
                            const queen = trumpCards.find(c => c.rank === 'Q');

                            projects.push({
                                type: 'بلوت',
                                cards: [king, queen],
                                points: 20
                            });
                        }
                    }
                }

                return projects;
            },

            findSequences(hand) {
                const sequences = [];
                const suitGroups = {};

                for (const card of hand) {
                    if (!suitGroups[card.suit]) suitGroups[card.suit] = [];
                    suitGroups[card.suit].push(card);
                }

                for (const [suit, cards] of Object.entries(suitGroups)) {
                    cards.sort((a, b) => a.getSequenceValue() - b.getSequenceValue());

                    let currentSeq = [cards[0]];

                    for (let i = 1; i < cards.length; i++) {
                        if (cards[i].getSequenceValue() === cards[i-1].getSequenceValue() + 1) {
                            currentSeq.push(cards[i]);
                        } else {
                            if (currentSeq.length >= 3) {
                                sequences.push([...currentSeq]);
                            }
                            currentSeq = [cards[i]];
                        }
                    }

                    if (currentSeq.length >= 3) {
                        sequences.push(currentSeq);
                    }
                }

                return sequences;
            },

            resolveProjectConflicts(team1Projects, team2Projects) {
                const getMaxPoints = (projects) =>
                    projects.length > 0 ? Math.max(...projects.map(p => p.points)) : 0;

                const team1Max = getMaxPoints(team1Projects);
                const team2Max = getMaxPoints(team2Projects);

                if (team1Max > team2Max) {
                    return { team1: team1Projects, team2: [] };
                } else if (team2Max > team1Max) {
                    return { team1: [], team2: team2Projects };
                } else if (team1Max === team2Max && team1Max > 0) {
                    // Tie: use first-declarer rule
                    const team1First = team1Projects.length > 0 ? Math.min(...team1Projects.map(p => p.declaredBy)) : Infinity;
                    const team2First = team2Projects.length > 0 ? Math.min(...team2Projects.map(p => p.declaredBy)) : Infinity;

                    if (team1First < team2First) {
                        return { team1: team1Projects, team2: [] };
                    } else {
                        return { team1: [], team2: team2Projects };
                    }
                } else {
                    return { team1: [], team2: [] };
                }
            }
        };

        // ============================================================
        // SECTION 8: SCORING SYSTEM
        // ============================================================

        const ScoringSystem = {
            calculateRoundScore() {
                const gameType = gameState.round.gameType;
                const buyingTeam = gameState.round.buyingTeam;

                let team1Bunts = this.calculateTrickPoints(gameState.round.team1Tricks, gameType);
                let team2Bunts = this.calculateTrickPoints(gameState.round.team2Tricks, gameType);

                const lastTrickTeam = gameState.round.team1Tricks.length === 4 &&
                    gameState.round.team2Tricks.length === 4
                    ? (gameState.round.team1Tricks.length > gameState.round.team2Tricks.length ? 0 : 1)
                    : (gameState.round.team1Tricks.length >= gameState.round.team2Tricks.length ? 0 : 1);

                if (lastTrickTeam === 0) {
                    team1Bunts += 10;
                } else {
                    team2Bunts += 10;
                }

                for (const proj of gameState.round.declaredProjects.team1) {
                    team1Bunts += proj.points;
                }
                for (const proj of gameState.round.declaredProjects.team2) {
                    team2Bunts += proj.points;
                }

                const team1Won8 = gameState.round.team1Tricks.length === 8;
                const team2Won8 = gameState.round.team2Tricks.length === 8;

                let kapoot = false;
                if (team1Won8) {
                    team1Bunts += gameType === 'hokum' ? 25 : 44;
                    kapoot = true;
                } else if (team2Won8) {
                    team2Bunts += gameType === 'hokum' ? 25 : 44;
                    kapoot = true;
                }

                let team1Points = this.buntsToPoints(team1Bunts, gameType);
                let team2Points = this.buntsToPoints(team2Bunts, gameType);

                team1Points *= gameState.round.doubleLevel;
                team2Points *= gameState.round.doubleLevel;

                let result;
                const buyerPoints = buyingTeam === 0 ? team1Bunts : team2Bunts;
                const opponentPoints = buyingTeam === 0 ? team2Bunts : team1Bunts;

                if (kapoot) {
                    result = 'كبوت';
                } else if (buyerPoints > opponentPoints) {
                    result = 'فاز المشتري';
                } else {
                    if (buyingTeam === 0) {
                        team2Points += team1Points;
                        team1Points = 0;
                    } else {
                        team1Points += team2Points;
                        team2Points = 0;
                    }
                    result = 'خسر المشتري';
                }

                return {
                    team1Points,
                    team2Points,
                    team1Bunts,
                    team2Bunts,
                    result
                };
            },

            calculateTrickPoints(tricks, gameType) {
                let total = 0;
                const trumpSuit = gameState.round.trumpSuit;

                for (const trick of tricks) {
                    for (const card of trick) {
                        total += card.getPointValue(gameType, card.suit === trumpSuit);
                    }
                }

                return total;
            },

            buntsToPoints(bunts, gameType) {
                if (gameType === 'sun') {
                    return Math.round((bunts * 2) / 10);
                }
                return Math.round(bunts / 10);
            }
        };

        // ============================================================
        // SECTION 9: AI AGENT BASE CLASS
        // ============================================================

        class BalootAIAgent {
            constructor(playerIndex, teamIndex) {
                this.playerIndex = playerIndex;
                this.teamIndex = teamIndex;
                this.name = 'AI Agent';
            }

            onRoundStart(roundInfo) {}

            onReceiveHand(hand) {}

            async decideBid(biddingState) {
                throw new Error('decideBid يجب تنفيذه');
            }

            async declareProjects(detectedProjects) {
                return detectedProjects.slice(0, 2);
            }

            async decideCard(trickState, legalCards) {
                throw new Error('decideCard يجب تنفيذه');
            }

            onCardPlayed(playerIndex, card) {}

            onTrickWon(winnerIndex, trickCards) {}
        }

        // ============================================================
        // SECTION 10: DEFAULT AI AGENTS
        // ============================================================

        class GreedyAI extends BalootAIAgent {
            constructor(playerIndex, teamIndex) {
                super(playerIndex, teamIndex);
                this.name = 'GreedyAI';
                this.hand = [];
            }

            onReceiveHand(hand) {
                this.hand = [...hand];
            }

            async decideBid(biddingState) {
                const { biddingCard, biddingRound } = biddingState;

                const trumpCards = this.hand.filter(c => c.suit === biddingCard.suit);
                const hasJack = trumpCards.some(c => c.rank === 'J');
                const hasNine = trumpCards.some(c => c.rank === '9');

                if (biddingRound === 1) {
                    if (trumpCards.length >= 3 && (hasJack || hasNine)) {
                        return { bidType: BID_TYPES.HOKUM };
                    }

                    const aces = this.hand.filter(c => c.rank === 'A').length;
                    if (aces >= 3) {
                        return { bidType: BID_TYPES.SUN };
                    }

                    return { bidType: BID_TYPES.PASS };
                } else {
                    // Check if Ashkal is a good option (high cards in hand)
                    const highCards = this.hand.filter(c => ['A', '10', 'K'].includes(c.rank)).length;
                    if (highCards >= 4) {
                        return { bidType: BID_TYPES.ASHKAL };
                    }

                    for (const suit of Object.values(SUITS)) {
                        if (suit === biddingCard.suit) continue;
                        const suitCards = this.hand.filter(c => c.suit === suit);
                        const hasJ = suitCards.some(c => c.rank === 'J');
                        const has9 = suitCards.some(c => c.rank === '9');
                        if (suitCards.length >= 3 && (hasJ || has9)) {
                            return { bidType: BID_TYPES.HOKUM_SECOND, suitChoice: suit };
                        }
                    }
                    return { bidType: BID_TYPES.PASS };
                }
            }

            async decideCard(trickState, legalCards) {
                const { currentTrick, trumpSuit, gameType } = trickState;
                const partnerIndex = (this.playerIndex + 2) % 4;

                if (currentTrick.length === 0) {
                    return legalCards.reduce((best, card) =>
                        card.getRankingPower(gameType, card.suit === trumpSuit) >
                        best.getRankingPower(gameType, best.suit === trumpSuit) ? card : best
                    );
                }

                const ledSuit = currentTrick[0].card.suit;
                const currentWinner = TrickSystem.getCurrentWinner();
                const partnerIsWinning = currentWinner && currentWinner.playerIndex === partnerIndex;

                if (partnerIsWinning) {
                    // Protect partner's high cards by prioritizing throw-away cards
                    const lowValueCards = legalCards.filter(c => ['7', '8', '9'].includes(c.rank));
                    if (lowValueCards.length > 0) {
                        return lowValueCards.reduce((lowest, card) =>
                            card.getPointValue(gameType, card.suit === trumpSuit) <
                            lowest.getPointValue(gameType, lowest.suit === trumpSuit) ? card : lowest
                        );
                    }
                }

                const canFollow = legalCards.some(c => c.suit === ledSuit);

                if (canFollow) {
                    const followCards = legalCards.filter(c => c.suit === ledSuit);
                    return followCards.reduce((best, card) =>
                        card.getRankingPower(gameType, card.suit === trumpSuit) >
                        best.getRankingPower(gameType, best.suit === trumpSuit) ? card : best
                    );
                }

                return legalCards.reduce((lowest, card) =>
                    card.getPointValue(gameType, card.suit === trumpSuit) <
                    lowest.getPointValue(gameType, lowest.suit === trumpSuit) ? card : lowest
                );
            }
        }

        class StrategicAI extends BalootAIAgent {
            constructor(playerIndex, teamIndex) {
                super(playerIndex, teamIndex);
                this.name = 'StrategicAI';
                this.hand = [];
                this.playedCards = [];
            }

            onRoundStart(roundInfo) {
                this.playedCards = [];
            }

            onReceiveHand(hand) {
                this.hand = [...hand];
            }

            onCardPlayed(playerIndex, card) {
                this.playedCards.push({ playerIndex, card });
            }

            async decideBid(biddingState) {
                const { biddingCard, biddingRound } = biddingState;

                const trumpCards = this.hand.filter(c => c.suit === biddingCard.suit);
                const hasJack = trumpCards.some(c => c.rank === 'J');
                const hasNine = trumpCards.some(c => c.rank === '9');

                const hokumScore = trumpCards.length * 10 +
                    (hasJack ? 25 : 0) +
                    (hasNine ? 15 : 0);

                if (biddingRound === 1) {
                    if (hokumScore >= 45) {
                        return { bidType: BID_TYPES.HOKUM };
                    }

                    const aces = this.hand.filter(c => c.rank === 'A').length;
                    const tens = this.hand.filter(c => c.rank === '10').length;
                    if (aces >= 2 && (aces + tens) >= 4) {
                        return { bidType: BID_TYPES.SUN };
                    }

                    return { bidType: BID_TYPES.PASS };
                } else {
                    // Check if Ashkal is a good option (high cards in hand)
                    const highCards = this.hand.filter(c => ['A', '10', 'K'].includes(c.rank)).length;
                    if (highCards >= 4) {
                        return { bidType: BID_TYPES.ASHKAL };
                    }

                    let bestSuit = null;
                    let bestScore = 0;

                    for (const suit of Object.values(SUITS)) {
                        if (suit === biddingCard.suit) continue;
                        const suitCards = this.hand.filter(c => c.suit === suit);
                        const hasJ = suitCards.some(c => c.rank === 'J');
                        const has9 = suitCards.some(c => c.rank === '9');
                        const score = suitCards.length * 10 + (hasJ ? 25 : 0) + (has9 ? 15 : 0);
                        if (score > bestScore) {
                            bestScore = score;
                            bestSuit = suit;
                        }
                    }

                    if (bestScore >= 35 && bestSuit) {
                        return { bidType: BID_TYPES.HOKUM_SECOND, suitChoice: bestSuit };
                    }

                    return { bidType: BID_TYPES.PASS };
                }
            }

            async decideCard(trickState, legalCards) {
                const { currentTrick, trumpSuit, gameType } = trickState;
                const partnerIndex = (this.playerIndex + 2) % 4;

                if (currentTrick.length === 0) {
                    const nonTrump = legalCards.filter(c => c.suit !== trumpSuit);
                    const target = nonTrump.length > 0 ? nonTrump : legalCards;
                    return target.reduce((best, card) =>
                        card.getRankingPower(gameType, card.suit === trumpSuit) >
                        best.getRankingPower(gameType, best.suit === trumpSuit) ? card : best
                    );
                }

                const ledSuit = currentTrick[0].card.suit;
                let currentWinner = currentTrick[0];
                for (const play of currentTrick.slice(1)) {
                    if (TrickSystem.cardBeats(play.card, currentWinner.card, ledSuit, trumpSuit, gameType)) {
                        currentWinner = play;
                    }
                }

                const partnerIsWinning = currentWinner.playerIndex === partnerIndex;

                if (partnerIsWinning) {
                    // Protect partner's high cards by prioritizing throw-away cards
                    const lowValueCards = legalCards.filter(c => ['7', '8', '9'].includes(c.rank));
                    if (lowValueCards.length > 0) {
                        return lowValueCards.reduce((lowest, card) =>
                            card.getPointValue(gameType, card.suit === trumpSuit) <
                            lowest.getPointValue(gameType, lowest.suit === trumpSuit) ? card : lowest
                        );
                    }
                    return legalCards.reduce((lowest, card) =>
                        card.getPointValue(gameType, card.suit === trumpSuit) <
                        lowest.getPointValue(gameType, lowest.suit === trumpSuit) ? card : lowest
                    );
                }

                const winningCards = legalCards.filter(c =>
                    TrickSystem.cardBeats(c, currentWinner.card, ledSuit, trumpSuit, gameType)
                );

                if (winningCards.length > 0) {
                    return winningCards.reduce((lowest, card) =>
                        card.getRankingPower(gameType, card.suit === trumpSuit) <
                        lowest.getRankingPower(gameType, lowest.suit === trumpSuit) ? card : lowest
                    );
                }

                return legalCards.reduce((lowest, card) =>
                    card.getPointValue(gameType, card.suit === trumpSuit) <
                    lowest.getPointValue(gameType, lowest.suit === trumpSuit) ? card : lowest
                );
            }
        }

        // ============================================================
        // SECTION 10.5: AI AGENT REGISTRY
        // ============================================================

        const AIAgentRegistry = {
            agents: new Map([
                ['GreedyAI', GreedyAI],
                ['StrategicAI', StrategicAI]
            ]),

            register(name, agentClass) {
                this.agents.set(name, agentClass);
            },

            create(name, playerIndex, teamIndex) {
                const AgentClass = this.agents.get(name);
                if (!AgentClass) throw new Error(`الوكيل '${name}' غير موجود`);
                return new AgentClass(playerIndex, teamIndex);
            },

            list() {
                return Array.from(this.agents.keys());
            }
        };

        // ============================================================
        // SECTION 11: GAME CONTROLLER
        // ============================================================

        const GameController = {
            async startNewGame() {
                gameState.match = {
                    team1Score: 0,
                    team2Score: 0,
                    roundNumber: 1,
                    dealerIndex: Math.floor(Math.random() * 4),
                    winner: null,
                    isRunning: true
                };
                gameState.history = { actions: [], currentIndex: -1, isReplaying: false };

                const team1El = document.getElementById('team1AgentName');
                const team2El = document.getElementById('team2AgentName');
                const team1Agent = team1El.dataset.registryName || team1El.textContent;
                const team2Agent = team2El.dataset.registryName || team2El.textContent;

                gameState.players[0].agent = AIAgentRegistry.create(team1Agent, 0, 0);
                gameState.players[1].agent = AIAgentRegistry.create(team2Agent, 1, 1);
                gameState.players[2].agent = AIAgentRegistry.create(team1Agent, 2, 0);
                gameState.players[3].agent = AIAgentRegistry.create(team2Agent, 3, 1);

                UIRenderer.updatePlayerInfo();
                UIRenderer.renderScoreboard();
                UIRenderer.log('بدأت اللعبة الجديدة!', 'success');
                document.getElementById('gameEndOverlay').classList.remove('active');

                this.recordAction('gameStart', {});
                await this.startRound();
            },

            async startRound() {
                gameState.round = JSON.parse(JSON.stringify(initialRoundState));
                gameState.round.phase = 'dealing';

                gameState.deck.cards = DeckManager.shuffle(DeckManager.createDeck());

                DeckManager.deal(1);

                for (const player of gameState.players) {
                    player.agent.onRoundStart({ dealerIndex: gameState.match.dealerIndex });
                    player.agent.onReceiveHand([...player.hand]);
                }

                this.recordAction('roundStart', { roundNumber: gameState.match.roundNumber });

                UIRenderer.renderAllHands();
                UIRenderer.renderScoreboard();
                UIRenderer.log(`الجولة ${gameState.match.roundNumber} - التوزيع...`, 'info');

                await this.delay(500);
                await this.runBiddingPhase();
            },

            async runBiddingPhase() {
                BiddingSystem.startBidding();
                UIRenderer.showBiddingOverlay();

                let biddingComplete = false;
                let reshuffle = false;

                while (!biddingComplete && gameState.match.isRunning) {
                    const currentPlayer = gameState.round.currentBidder;
                    const agent = gameState.players[currentPlayer].agent;

                    UIRenderer.updateBiddingStatus(currentPlayer);
                    TimerSystem.start(currentPlayer);

                    const validBids = BiddingSystem.getValidBids();

                    let bidDecision;
                    try {
                        bidDecision = await this.withTimeout(
                            agent.decideBid({
                                biddingCard: gameState.round.biddingCard,
                                biddingRound: gameState.round.biddingRound,
                                bids: gameState.round.bids,
                                validBids
                            }),
                            gameState.config.aiDecisionTimeout
                        );
                    } catch (e) {
                        bidDecision = { bidType: BID_TYPES.PASS };
                    }

                    TimerSystem.stop();

                    if (!bidDecision || !validBids.includes(bidDecision.bidType)) {
                        bidDecision = { bidType: BID_TYPES.PASS };
                    }

                    const result = BiddingSystem.processBid(currentPlayer, bidDecision.bidType, bidDecision.suitChoice);

                    this.recordAction('bid', { playerIndex: currentPlayer, ...bidDecision, result });
                    UIRenderer.addBidToHistory(currentPlayer, bidDecision);
                    UIRenderer.log(`${gameState.players[currentPlayer].name} يزايد: ${BID_NAMES_AR[bidDecision.bidType] || bidDecision.bidType}`, 'bid');

                    await this.delay(600);

                    if (result.endBidding) {
                        biddingComplete = true;
                        reshuffle = result.reshuffle || false;
                    }
                }

                UIRenderer.hideBiddingOverlay();

                if (reshuffle) {
                    UIRenderer.log('الجميع مرر - إعادة الخلط...', 'warning');
                    gameState.match.dealerIndex = (gameState.match.dealerIndex + 1) % 4;
                    await this.delay(1000);
                    await this.startRound();
                    return;
                }

                // Update player info to show buyer badge
                UIRenderer.updatePlayerInfo();

                DeckManager.deal(2);

                gameState.players.forEach(p => {
                    p.hand = DeckManager.sortHand(p.hand, gameState.round.trumpSuit);
                    p.agent.onReceiveHand([...p.hand]);
                });

                UIRenderer.renderAllHands();
                UIRenderer.updateTrumpIndicator();
                UIRenderer.log(`${gameState.players[gameState.round.buyer].name} يشتري ${gameState.round.gameType === 'sun' ? 'صن' : 'حكم'}${gameState.round.trumpSuit ? ' (' + SUIT_SYMBOLS[gameState.round.trumpSuit] + ')' : ''}`, 'success');

                await this.delay(800);

                // Doubling phase
                await this.handleDoubling();

                await this.runPlayingPhase();
            },

            async handleDoubling() {
                // Per rules line 126: Sun only allows 1 double, Hokum allows up to 3 (4x)
                const maxDoubles = gameState.round.gameType === 'sun' ? 1 : 3;

                while (gameState.round.doubleLevel < maxDoubles) {
                    const nextDoubler = this.getNextDoubler();
                    if (nextDoubler === null) break;  // No one can double

                    const agent = gameState.players[nextDoubler].agent;
                    const shouldDouble = await agent.decideDouble(gameState);

                    if (shouldDouble) {
                        gameState.round.doubleLevel++;
                        gameState.round.lastDoubler = nextDoubler;

                        // Per rules line 132-139: Update locked state for Hokum
                        // Level 1 (Double) → locked, Level 2 (Triple) → open, Level 3 (Four) → locked
                        if (gameState.round.gameType === 'hokum') {
                            gameState.round.isLocked = (gameState.round.doubleLevel % 2 === 1);
                        }

                        const doublerName = gameState.players[nextDoubler].name;
                        const doubleNames = ['', 'دبل (2x)', 'ثري (3x)', 'فور (4x)'];
                        UIRenderer.log(`${doublerName}: ${doubleNames[gameState.round.doubleLevel]}`, 'warning');
                        await this.delay(800);
                    } else {
                        break;  // Player declined, end doubling
                    }
                }
            },

            getNextDoubler() {
                const buyer = gameState.round.buyer;
                const buyingTeam = gameState.round.buyingTeam;
                const currentLevel = gameState.round.doubleLevel;

                if (currentLevel === 0) {
                    // Opponent team can double - pick first opponent after buyer
                    for (let i = 1; i <= 3; i++) {
                        const playerIndex = (buyer + i) % 4;
                        if (gameState.players[playerIndex].teamIndex !== buyingTeam) {
                            return playerIndex;
                        }
                    }
                } else {
                    // Alternate between teams
                    const lastDoubler = gameState.round.lastDoubler;
                    const lastDoublerTeam = gameState.players[lastDoubler].teamIndex;

                    // Next doubler is from the other team
                    for (let i = 1; i <= 3; i++) {
                        const playerIndex = (lastDoubler + i) % 4;
                        if (gameState.players[playerIndex].teamIndex !== lastDoublerTeam) {
                            return playerIndex;
                        }
                    }
                }

                return null;  // No valid doubler
            },

            async runPlayingPhase() {
                gameState.round.phase = 'playing';
                gameState.round.trickNumber = 1;
                gameState.round.trickLeader = (gameState.match.dealerIndex + 1) % 4;
                gameState.round.currentPlayer = gameState.round.trickLeader;

                // Update player info to show buyer badge now that phase is 'playing'
                UIRenderer.updatePlayerInfo();

                await this.handleProjects();

                while (gameState.round.trickNumber <= 8 && gameState.match.isRunning) {
                    await this.playTrick();
                }

                if (gameState.match.isRunning) {
                    await this.endRound();
                }
            },

            async handleProjects() {
                for (const player of gameState.players) {
                    const projects = ProjectSystem.detectProjects(
                        player.hand,
                        gameState.round.gameType,
                        gameState.round.trumpSuit
                    );

                    if (projects.length > 0) {
                        const declared = await player.agent.declareProjects(projects);
                        const teamProjects = player.teamIndex === 0
                            ? gameState.round.declaredProjects.team1
                            : gameState.round.declaredProjects.team2;

                        teamProjects.push(...declared.map(p => {
                            // Track Baloot declaration
                            if (p.type === 'بلوت') {
                                const teamKey = player.teamIndex === 0 ? 'team1' : 'team2';
                                gameState.round.balootDeclared[teamKey] = true;
                            }

                            return { ...p, declaredBy: player.index };
                        }));

                        if (declared.length > 0) {
                            UIRenderer.log(`${player.name} يعلن: ${declared.map(p => p.type).join('، ')}`, 'success');
                        }
                    }
                }

                const resolved = ProjectSystem.resolveProjectConflicts(
                    gameState.round.declaredProjects.team1,
                    gameState.round.declaredProjects.team2
                );
                gameState.round.declaredProjects = resolved;

                if (resolved.team1.length > 0 || resolved.team2.length > 0) {
                    UIRenderer.showProjectsModal(resolved);
                    await UIRenderer.waitForProjectsModalClose();
                }
            },

            async playTrick() {
                gameState.round.currentTrick = [];
                UIRenderer.clearTrickArea();
                UIRenderer.updateTrickInfo();

                for (let i = 0; i < 4 && gameState.match.isRunning; i++) {
                    const playerIndex = gameState.round.currentPlayer;
                    const agent = gameState.players[playerIndex].agent;

                    UIRenderer.highlightCurrentPlayer(playerIndex);
                    TimerSystem.start(playerIndex);

                    const legalCards = TrickSystem.getLegalCards(playerIndex);
                    UIRenderer.highlightLegalCards(playerIndex, legalCards);

                    let card;
                    try {
                        card = await this.withTimeout(
                            agent.decideCard({
                                currentTrick: gameState.round.currentTrick,
                                trumpSuit: gameState.round.trumpSuit,
                                gameType: gameState.round.gameType,
                                trickNumber: gameState.round.trickNumber
                            }, legalCards),
                            gameState.config.aiDecisionTimeout
                        );
                    } catch (e) {
                        card = legalCards[0];
                    }

                    TimerSystem.stop();

                    if (!card || !legalCards.some(c => c.id === card.id)) {
                        card = legalCards[0];
                    }

                    const result = TrickSystem.playCard(playerIndex, card);

                    // Track played card globally for Ikah detection
                    gameState.round.playedCards.push(card);

                    for (const player of gameState.players) {
                        player.agent.onCardPlayed(playerIndex, card);
                    }

                    this.recordAction('playCard', { playerIndex, card: card.id, trickNumber: gameState.round.trickNumber });

                    // Detect Ikah before rendering and logging
                    const isIkah = TrickSystem.isIkah(card, playerIndex);

                    UIRenderer.renderCardInTrick(playerIndex, card, isIkah);
                    UIRenderer.renderPlayerHand(playerIndex);

                    const playerName = gameState.players[playerIndex].name;
                    if (isIkah) {
                        UIRenderer.log(`${playerName} يلعب ${card.toString()} - اكه! (Ikah!)`, 'ikah');
                    } else {
                        UIRenderer.log(`${playerName} يلعب ${card.toString()}`, 'play');
                    }

                    await this.delay(400);
                }

                const trickResult = TrickSystem.resolveTrick();

                for (const player of gameState.players) {
                    player.agent.onTrickWon(trickResult.winner, trickResult.cards);
                }

                this.recordAction('trickWon', trickResult);
                UIRenderer.log(`${gameState.players[trickResult.winner].name} يفوز بالأكلة ${trickResult.trickNumber}`, 'success');

                await this.delay(800);
                UIRenderer.clearTrickArea();
            },

            async endRound() {
                gameState.round.phase = 'scoring';

                const scoreResult = ScoringSystem.calculateRoundScore();

                gameState.match.team1Score += scoreResult.team1Points;
                gameState.match.team2Score += scoreResult.team2Points;

                this.recordAction('roundEnd', scoreResult);

                UIRenderer.renderScoreboard();
                UIRenderer.log(`الجولة ${gameState.match.roundNumber} - الفريق 1: +${scoreResult.team1Points}، الفريق 2: +${scoreResult.team2Points} (${scoreResult.result})`, 'info');

                await this.delay(1500);

                if (gameState.match.team1Score >= 152) {
                    gameState.match.winner = 0;
                    UIRenderer.showGameEnd(0);
                    gameState.match.isRunning = false;
                    return;
                } else if (gameState.match.team2Score >= 152) {
                    gameState.match.winner = 1;
                    UIRenderer.showGameEnd(1);
                    gameState.match.isRunning = false;
                    return;
                }

                gameState.match.dealerIndex = (gameState.match.dealerIndex + 1) % 4;
                gameState.match.roundNumber++;
                await this.startRound();
            },

            recordAction(type, data) {
                gameState.history.actions.push({
                    timestamp: Date.now(),
                    type,
                    data
                });
                gameState.history.currentIndex = gameState.history.actions.length - 1;
                document.getElementById('replaySlider').max = gameState.history.currentIndex;
                document.getElementById('replaySlider').value = gameState.history.currentIndex;
            },

            setSpeed(speed) {
                gameState.config.animationSpeed = speed;
            },

            async withTimeout(promise, ms) {
                return Promise.race([
                    promise,
                    new Promise((_, reject) => setTimeout(() => reject(new Error('انتهت المهلة')), ms))
                ]);
            },

            delay(ms) {
                const multiplier = {
                    slow: 2,
                    normal: 1,
                    fast: 0.5,
                    instant: 0.05
                }[gameState.config.animationSpeed];
                return new Promise(resolve => setTimeout(resolve, ms * multiplier));
            }
        };

        // ============================================================
        // SECTION 12: UI RENDERING
        // ============================================================

        const UIRenderer = {
            renderAllHands() {
                for (let i = 0; i < 4; i++) {
                    this.renderPlayerHand(i);
                }
            },

            renderPlayerHand(playerIndex) {
                const player = gameState.players[playerIndex];
                const el = document.getElementById(`hand${playerIndex}`);
                el.innerHTML = '';

                for (const card of player.hand) {
                    const cardEl = card.toElement();
                    if (gameState.round.trumpSuit && card.suit === gameState.round.trumpSuit) {
                        cardEl.classList.add('trump');
                    }
                    el.appendChild(cardEl);
                }
            },

            highlightLegalCards(playerIndex, legalCards) {
                const el = document.getElementById(`hand${playerIndex}`);
                const cardEls = el.querySelectorAll('.card');
                cardEls.forEach(cardEl => {
                    const isLegal = legalCards.some(c => c.id === cardEl.dataset.id);
                    cardEl.classList.toggle('legal', isLegal);
                });
            },

            highlightCurrentPlayer(playerIndex) {
                document.querySelectorAll('.player-info').forEach(el => el.classList.remove('current-turn'));
                document.getElementById(`playerInfo${playerIndex}`).classList.add('current-turn');
            },

            renderCardInTrick(playerIndex, card, isIkah = false) {
                const position = gameState.players[playerIndex].position;
                const trickCardEl = document.querySelector(`.trick-card[data-position="${position}"]`);
                trickCardEl.innerHTML = '';
                const cardElement = card.toElement();
                if (isIkah) {
                    cardElement.classList.add('ikah');
                }
                trickCardEl.appendChild(cardElement);
            },

            clearTrickArea() {
                document.querySelectorAll('.trick-card').forEach(el => el.innerHTML = '');
            },

            updateTrickInfo() {
                document.getElementById('trickInfo').textContent = `الأكلة ${gameState.round.trickNumber}/8`;
            },

            updateTrumpIndicator() {
                const el = document.getElementById('trumpIndicator');
                if (gameState.round.gameType === 'sun') {
                    el.className = 'trump-indicator sun';
                    el.innerHTML = '<span>صن (بدون حكم)</span>';
                } else {
                    el.className = 'trump-indicator hokum';
                    el.innerHTML = `<span>حكم</span><span class="trump-suit" style="color: ${gameState.round.trumpSuit === 'hearts' || gameState.round.trumpSuit === 'diamonds' ? 'var(--card-red)' : 'var(--text-primary)'}">${SUIT_SYMBOLS[gameState.round.trumpSuit]}</span>`;
                }
            },

            renderScoreboard() {
                document.getElementById('team1Score').textContent = gameState.match.team1Score;
                document.getElementById('team2Score').textContent = gameState.match.team2Score;
                document.getElementById('roundNumber').textContent = gameState.match.roundNumber;

                if (gameState.round.buyer !== null) {
                    document.getElementById('buyerInfo').textContent = ` | المشتري: ${gameState.players[gameState.round.buyer].name}`;
                } else {
                    document.getElementById('buyerInfo').textContent = '';
                }
            },

            updatePlayerInfo() {
                for (let i = 0; i < 4; i++) {
                    const player = gameState.players[i];
                    const el = document.getElementById(`playerInfo${i}`);
                    el.querySelector('.player-name').textContent = player.name;
                    el.querySelector('.player-agent').textContent = player.agent.name;

                    // Remove existing badges
                    const existingBuyerBadge = el.querySelector('.buyer-badge');
                    if (existingBuyerBadge) {
                        existingBuyerBadge.remove();
                    }

                    const existingDealerBadge = el.querySelector('.dealer-badge');
                    if (existingDealerBadge) {
                        existingDealerBadge.remove();
                    }

                    // Per rules line 7-13: Add dealer badge during bidding
                    if (gameState.round.phase === 'bidding' &&
                        gameState.match.dealerIndex === i) {
                        const badge = document.createElement('div');
                        badge.className = 'dealer-badge';
                        badge.textContent = 'م';  // Arabic: م for موزع (Dealer)
                        badge.title = 'الموزع';
                        el.appendChild(badge);
                    }

                    // Add buyer badge if this player is the buyer
                    if (gameState.round.buyer === i && gameState.round.phase !== 'bidding') {
                        const badge = document.createElement('div');
                        badge.className = 'buyer-badge';

                        if (gameState.round.gameType === 'hokum' && gameState.round.trumpSuit) {
                            const suitSymbols = { spades: '♠', hearts: '♥', diamonds: '♦', clubs: '♣' };
                            badge.textContent = suitSymbols[gameState.round.trumpSuit];
                        } else if (gameState.round.gameType === 'sun') {
                            badge.innerHTML = '☀️';
                            badge.classList.add('sun-badge');
                        }

                        el.appendChild(badge);
                    }
                }
            },

            showBiddingOverlay() {
                const overlay = document.getElementById('biddingOverlay');
                overlay.classList.add('active');

                const cardDisplay = document.getElementById('biddingCardDisplay');
                cardDisplay.innerHTML = '';
                cardDisplay.appendChild(gameState.round.biddingCard.toElement());

                document.getElementById('bidHistory').innerHTML = '<div style="color: var(--text-muted); text-align: center;">ستظهر المزايدات هنا...</div>';
            },

            hideBiddingOverlay() {
                document.getElementById('biddingOverlay').classList.remove('active');
            },

            updateBiddingStatus(playerIndex) {
                document.getElementById('biddingStatus').textContent = `دور ${gameState.players[playerIndex].name} للمزايدة (الجولة ${gameState.round.biddingRound})`;
            },

            addBidToHistory(playerIndex, bidDecision) {
                const history = document.getElementById('bidHistory');
                if (history.querySelector('div[style]')) {
                    history.innerHTML = '';
                }

                const entry = document.createElement('div');
                entry.className = 'bid-entry';
                const bidName = BID_NAMES_AR[bidDecision.bidType] || bidDecision.bidType;
                entry.textContent = `${gameState.players[playerIndex].name}: ${bidName}${bidDecision.suitChoice ? ' (' + SUIT_SYMBOLS[bidDecision.suitChoice] + ')' : ''}`;
                history.appendChild(entry);
            },

            showProjectsModal(projects) {
                const modal = document.getElementById('projectsModal');
                const list = document.getElementById('projectsList');
                list.innerHTML = '';

                const renderTeam = (teamProjects, teamName) => {
                    if (teamProjects.length === 0) return;
                    const header = document.createElement('h4');
                    header.textContent = teamName;
                    list.appendChild(header);

                    for (const proj of teamProjects) {
                        const item = document.createElement('div');
                        item.className = 'project-item';
                        item.innerHTML = `
                            <div>
                                <strong>${proj.type}</strong>
                                <div class="project-cards">
                                    ${proj.cards.map(c => c.toElement().outerHTML).join('')}
                                </div>
                            </div>
                            <span class="project-points">+${proj.points}</span>
                        `;
                        list.appendChild(item);
                    }
                };

                renderTeam(projects.team1, 'الفريق 1');
                renderTeam(projects.team2, 'الفريق 2');

                modal.classList.add('active');
            },

            closeProjectsModal() {
                document.getElementById('projectsModal').classList.remove('active');
                if (UIRenderer._projectsModalResolve) {
                    UIRenderer._projectsModalResolve();
                    UIRenderer._projectsModalResolve = null;
                }
            },

            waitForProjectsModalClose() {
                return new Promise(resolve => {
                    UIRenderer._projectsModalResolve = resolve;
                });
            },

            showGameEnd(winnerTeam) {
                const overlay = document.getElementById('gameEndOverlay');
                document.getElementById('winnerText').textContent = `الفريق ${winnerTeam + 1} يفوز!`;

                const score1 = document.getElementById('finalScore1');
                const score2 = document.getElementById('finalScore2');

                score1.classList.toggle('winner', winnerTeam === 0);
                score2.classList.toggle('winner', winnerTeam === 1);

                score1.querySelector('.score').textContent = gameState.match.team1Score;
                score2.querySelector('.score').textContent = gameState.match.team2Score;

                overlay.classList.add('active');
            },

            log(message, type = 'info') {
                const log = document.getElementById('gameLog');
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;

                const time = new Date().toLocaleTimeString('ar-SA', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                entry.innerHTML = `<span class="log-time">[${time}]</span> ${message}`;

                log.appendChild(entry);
                log.scrollTop = log.scrollHeight;
            }
        };

        // ============================================================
        // SECTION 13: REPLAY SYSTEM
        // ============================================================

        const ReplaySystem = {
            isPlaying: false,
            playInterval: null,

            goToAction(index) {
                if (index < 0 || index >= gameState.history.actions.length) return;

                gameState.history.currentIndex = index;
                document.getElementById('replaySlider').value = index;

                const action = gameState.history.actions[index];
                document.getElementById('replayInfo').innerHTML = `
                    <strong>الحدث ${index + 1}:</strong> ${action.type}<br>
                    <small>${JSON.stringify(action.data).substring(0, 100)}...</small>
                `;
            },

            stepForward() {
                this.goToAction(gameState.history.currentIndex + 1);
            },

            stepBack() {
                this.goToAction(gameState.history.currentIndex - 1);
            },

            goToStart() {
                this.goToAction(0);
            },

            goToEnd() {
                this.goToAction(gameState.history.actions.length - 1);
            },

            toggleAutoPlay() {
                const btn = document.getElementById('replayPlayBtn');

                if (this.isPlaying) {
                    clearInterval(this.playInterval);
                    this.isPlaying = false;
                    btn.innerHTML = '&#9654;';
                } else {
                    this.isPlaying = true;
                    btn.innerHTML = '&#10074;&#10074;';
                    this.playInterval = setInterval(() => {
                        if (gameState.history.currentIndex >= gameState.history.actions.length - 1) {
                            this.toggleAutoPlay();
                            return;
                        }
                        this.stepForward();
                    }, 1000);
                }
            },

            stop() {
                if (this.isPlaying) {
                    clearInterval(this.playInterval);
                    this.isPlaying = false;
                    document.getElementById('replayPlayBtn').innerHTML = '&#9654;';
                }
            }
        };

        // ============================================================
        // SECTION 14: TIMER SYSTEM
        // ============================================================

        const TimerSystem = {
            interval: null,
            startTime: null,

            start(playerIndex) {
                this.stop();
                this.startTime = Date.now();
                const timeout = gameState.config.aiDecisionTimeout;

                const el = document.getElementById('timerDisplay');
                el.innerHTML = `
                    <div class="timer-bar">
                        <div class="timer-fill" id="timerFill"></div>
                    </div>
                    <div class="timer-text">${gameState.players[playerIndex].name} يفكر...</div>
                `;

                this.interval = setInterval(() => {
                    const elapsed = Date.now() - this.startTime;
                    const remaining = Math.max(0, timeout - elapsed);
                    const percent = (remaining / timeout) * 100;

                    const fill = document.getElementById('timerFill');
                    if (fill) {
                        fill.style.width = `${percent}%`;
                        fill.classList.toggle('warning', percent < 30);
                    }

                    if (remaining <= 0) {
                        this.stop();
                    }
                }, 100);
            },

            stop() {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
                document.getElementById('timerDisplay').innerHTML = '';
            }
        };

        // ============================================================
        // SECTION 15: AI UPLOAD SYSTEM
        // ============================================================

        const AIUploadSystem = {
            async handleUpload(event, teamIndex) {
                const file = event.target.files[0];
                if (!file) return;

                if (!file.name.endsWith('.js')) {
                    UIRenderer.log('خطأ: يرجى رفع ملف .js', 'error');
                    return;
                }

                try {
                    const code = await file.text();
                    const AgentClass = this.loadAgentCode(code);

                    if (!AgentClass) {
                        UIRenderer.log('خطأ: كود الوكيل غير صالح - يجب تعريف فئة CustomAgent', 'error');
                        return;
                    }

                    const agentName = `Custom_${teamIndex === 0 ? 'T1' : 'T2'}_${Date.now()}`;
                    AIAgentRegistry.register(agentName, AgentClass);

                    const testAgent = new AgentClass(0, 0);
                    const displayName = testAgent.name || agentName;

                    const nameEl = document.getElementById(`team${teamIndex + 1}AgentName`);
                    nameEl.textContent = displayName;
                    nameEl.dataset.registryName = agentName;
                    UIRenderer.log(`تم تحميل ذكاء الفريق ${teamIndex + 1}: ${displayName}`, 'success');

                } catch (err) {
                    UIRenderer.log(`خطأ في تحميل الذكاء: ${err.message}`, 'error');
                    console.error(err);
                }
            },

            loadAgentCode(code) {
                try {
                    const wrappedCode = `
                        (function(BalootAIAgent, BID_TYPES, SUITS, SUIT_SYMBOLS) {
                            ${code}
                            return typeof CustomAgent !== 'undefined' ? CustomAgent : null;
                        })
                    `;

                    const factory = eval(wrappedCode);
                    const AgentClass = factory(BalootAIAgent, BID_TYPES, SUITS, SUIT_SYMBOLS);

                    if (!AgentClass) return null;

                    const proto = AgentClass.prototype;
                    if (typeof proto.decideBid !== 'function' || typeof proto.decideCard !== 'function') {
                        throw new Error('الدوال المطلوبة مفقودة: decideBid, decideCard');
                    }

                    return AgentClass;
                } catch (err) {
                    console.error('فشل تحميل الوكيل:', err);
                    throw err;
                }
            },

            downloadTemplate() {
                const template = `// قالب وكيل البلوت للذكاء الاصطناعي
// لا تغير اسم الفئة 'CustomAgent'!

class CustomAgent extends BalootAIAgent {
    constructor(playerIndex, teamIndex) {
        super(playerIndex, teamIndex);
        this.name = 'ذكائي المخصص';  // غير هذا!
        this.version = '1.0.0';
        this.hand = [];
    }

    onRoundStart(roundInfo) {
        // يُستدعى عند بدء جولة جديدة
        // roundInfo: { dealerIndex }
    }

    onReceiveHand(hand) {
        // يُستدعى عند استلام الورق
        // hand: مصفوفة من كائنات Card مع { suit, rank, id }
        this.hand = [...hand];
    }

    async decideBid(biddingState) {
        // مطلوب: أرجع قرار المزايدة
        // biddingState: { biddingCard, biddingRound, bids, validBids }
        //
        // أرجع: { bidType: 'pass' | 'hokum' | 'sun' | 'hokum2', suitChoice?: 'clubs'|'diamonds'|'hearts'|'spades' }
        //
        // BID_TYPES المتاحة: PASS, HOKUM, SUN, HOKUM_SECOND

        // مثال: مزايدة عشوائية بسيطة
        const validBids = biddingState.validBids;
        const randomBid = validBids[Math.floor(Math.random() * validBids.length)];

        if (randomBid === 'hokum2') {
            // يجب اختيار نوع مختلف عن ورقة المزايدة
            const suits = ['clubs', 'diamonds', 'hearts', 'spades'];
            const availableSuits = suits.filter(s => s !== biddingState.biddingCard.suit);
            return { bidType: randomBid, suitChoice: availableSuits[0] };
        }

        return { bidType: randomBid };
    }

    async decideCard(trickState, legalCards) {
        // مطلوب: أرجع الورقة التي تريد لعبها
        // trickState: { currentTrick, trumpSuit, gameType, trickNumber }
        // legalCards: مصفوفة كائنات Card التي يمكنك لعبها قانونياً
        //
        // أرجع: كائن Card واحد من legalCards

        // مثال: لعب ورقة قانونية عشوائية
        return legalCards[Math.floor(Math.random() * legalCards.length)];
    }

    async declareProjects(detectedProjects) {
        // اختياري: اختر المشاريع التي تريد إعلانها
        // detectedProjects: مصفوفة من { type, cards, points }
        // أرجع: مصفوفة المشاريع للإعلان (أقصى 2)
        return detectedProjects.slice(0, 2);
    }

    onCardPlayed(playerIndex, card) {
        // يُستدعى عندما يلعب أي لاعب ورقة
        // استخدم هذا لتتبع الأوراق الملعوبة
    }

    onTrickWon(winnerIndex, trickCards) {
        // يُستدعى عند الفوز بأكلة
    }
}
`;

                const blob = new Blob([template], { type: 'text/javascript' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'custom_ai_template.js';
                a.click();
                URL.revokeObjectURL(url);

                UIRenderer.log('تم تحميل قالب الذكاء الاصطناعي!', 'success');
            },

            downloadDeveloperGuide() {
                const a = document.createElement('a');
                a.href = 'docs/ai_comprehensive_guide.md';
                a.download = 'ai_comprehensive_guide.md';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                UIRenderer.log('تم تحميل دليل المطور!', 'success');
            }
        };

        // ============================================================
        // SECTION 16: INITIALIZATION
        // ============================================================

        function init() {
            UIRenderer.log('تم تحميل ساحة البلوت للذكاء الاصطناعي. انقر "بدء لعبة جديدة" للبدء!', 'info');
            UIRenderer.renderScoreboard();
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
